// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'validate_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$ValidateFailureTearOff {
  const _$ValidateFailureTearOff();

  EmailNotVerified emailNotVerified() {
    return const EmailNotVerified();
  }

  VendorNotVerified vendorNotApproved() {
    return const VendorNotVerified();
  }

  BothNotValid bothNotValid() {
    return const BothNotValid();
  }

  UnknownError unknownError() {
    return const UnknownError();
  }
}

// ignore: unused_element
const $ValidateFailure = _$ValidateFailureTearOff();

mixin _$ValidateFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailNotVerified(),
    @required Result vendorNotApproved(),
    @required Result bothNotValid(),
    @required Result unknownError(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailNotVerified(),
    Result vendorNotApproved(),
    Result bothNotValid(),
    Result unknownError(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailNotVerified(EmailNotVerified value),
    @required Result vendorNotApproved(VendorNotVerified value),
    @required Result bothNotValid(BothNotValid value),
    @required Result unknownError(UnknownError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailNotVerified(EmailNotVerified value),
    Result vendorNotApproved(VendorNotVerified value),
    Result bothNotValid(BothNotValid value),
    Result unknownError(UnknownError value),
    @required Result orElse(),
  });
}

abstract class $ValidateFailureCopyWith<$Res> {
  factory $ValidateFailureCopyWith(
          ValidateFailure value, $Res Function(ValidateFailure) then) =
      _$ValidateFailureCopyWithImpl<$Res>;
}

class _$ValidateFailureCopyWithImpl<$Res>
    implements $ValidateFailureCopyWith<$Res> {
  _$ValidateFailureCopyWithImpl(this._value, this._then);

  final ValidateFailure _value;
  // ignore: unused_field
  final $Res Function(ValidateFailure) _then;
}

abstract class $EmailNotVerifiedCopyWith<$Res> {
  factory $EmailNotVerifiedCopyWith(
          EmailNotVerified value, $Res Function(EmailNotVerified) then) =
      _$EmailNotVerifiedCopyWithImpl<$Res>;
}

class _$EmailNotVerifiedCopyWithImpl<$Res>
    extends _$ValidateFailureCopyWithImpl<$Res>
    implements $EmailNotVerifiedCopyWith<$Res> {
  _$EmailNotVerifiedCopyWithImpl(
      EmailNotVerified _value, $Res Function(EmailNotVerified) _then)
      : super(_value, (v) => _then(v as EmailNotVerified));

  @override
  EmailNotVerified get _value => super._value as EmailNotVerified;
}

class _$EmailNotVerified implements EmailNotVerified {
  const _$EmailNotVerified();

  @override
  String toString() {
    return 'ValidateFailure.emailNotVerified()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is EmailNotVerified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailNotVerified(),
    @required Result vendorNotApproved(),
    @required Result bothNotValid(),
    @required Result unknownError(),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return emailNotVerified();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailNotVerified(),
    Result vendorNotApproved(),
    Result bothNotValid(),
    Result unknownError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailNotVerified != null) {
      return emailNotVerified();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailNotVerified(EmailNotVerified value),
    @required Result vendorNotApproved(VendorNotVerified value),
    @required Result bothNotValid(BothNotValid value),
    @required Result unknownError(UnknownError value),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return emailNotVerified(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailNotVerified(EmailNotVerified value),
    Result vendorNotApproved(VendorNotVerified value),
    Result bothNotValid(BothNotValid value),
    Result unknownError(UnknownError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emailNotVerified != null) {
      return emailNotVerified(this);
    }
    return orElse();
  }
}

abstract class EmailNotVerified implements ValidateFailure {
  const factory EmailNotVerified() = _$EmailNotVerified;
}

abstract class $VendorNotVerifiedCopyWith<$Res> {
  factory $VendorNotVerifiedCopyWith(
          VendorNotVerified value, $Res Function(VendorNotVerified) then) =
      _$VendorNotVerifiedCopyWithImpl<$Res>;
}

class _$VendorNotVerifiedCopyWithImpl<$Res>
    extends _$ValidateFailureCopyWithImpl<$Res>
    implements $VendorNotVerifiedCopyWith<$Res> {
  _$VendorNotVerifiedCopyWithImpl(
      VendorNotVerified _value, $Res Function(VendorNotVerified) _then)
      : super(_value, (v) => _then(v as VendorNotVerified));

  @override
  VendorNotVerified get _value => super._value as VendorNotVerified;
}

class _$VendorNotVerified implements VendorNotVerified {
  const _$VendorNotVerified();

  @override
  String toString() {
    return 'ValidateFailure.vendorNotApproved()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is VendorNotVerified);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailNotVerified(),
    @required Result vendorNotApproved(),
    @required Result bothNotValid(),
    @required Result unknownError(),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return vendorNotApproved();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailNotVerified(),
    Result vendorNotApproved(),
    Result bothNotValid(),
    Result unknownError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (vendorNotApproved != null) {
      return vendorNotApproved();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailNotVerified(EmailNotVerified value),
    @required Result vendorNotApproved(VendorNotVerified value),
    @required Result bothNotValid(BothNotValid value),
    @required Result unknownError(UnknownError value),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return vendorNotApproved(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailNotVerified(EmailNotVerified value),
    Result vendorNotApproved(VendorNotVerified value),
    Result bothNotValid(BothNotValid value),
    Result unknownError(UnknownError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (vendorNotApproved != null) {
      return vendorNotApproved(this);
    }
    return orElse();
  }
}

abstract class VendorNotVerified implements ValidateFailure {
  const factory VendorNotVerified() = _$VendorNotVerified;
}

abstract class $BothNotValidCopyWith<$Res> {
  factory $BothNotValidCopyWith(
          BothNotValid value, $Res Function(BothNotValid) then) =
      _$BothNotValidCopyWithImpl<$Res>;
}

class _$BothNotValidCopyWithImpl<$Res>
    extends _$ValidateFailureCopyWithImpl<$Res>
    implements $BothNotValidCopyWith<$Res> {
  _$BothNotValidCopyWithImpl(
      BothNotValid _value, $Res Function(BothNotValid) _then)
      : super(_value, (v) => _then(v as BothNotValid));

  @override
  BothNotValid get _value => super._value as BothNotValid;
}

class _$BothNotValid implements BothNotValid {
  const _$BothNotValid();

  @override
  String toString() {
    return 'ValidateFailure.bothNotValid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is BothNotValid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailNotVerified(),
    @required Result vendorNotApproved(),
    @required Result bothNotValid(),
    @required Result unknownError(),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return bothNotValid();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailNotVerified(),
    Result vendorNotApproved(),
    Result bothNotValid(),
    Result unknownError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bothNotValid != null) {
      return bothNotValid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailNotVerified(EmailNotVerified value),
    @required Result vendorNotApproved(VendorNotVerified value),
    @required Result bothNotValid(BothNotValid value),
    @required Result unknownError(UnknownError value),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return bothNotValid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailNotVerified(EmailNotVerified value),
    Result vendorNotApproved(VendorNotVerified value),
    Result bothNotValid(BothNotValid value),
    Result unknownError(UnknownError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bothNotValid != null) {
      return bothNotValid(this);
    }
    return orElse();
  }
}

abstract class BothNotValid implements ValidateFailure {
  const factory BothNotValid() = _$BothNotValid;
}

abstract class $UnknownErrorCopyWith<$Res> {
  factory $UnknownErrorCopyWith(
          UnknownError value, $Res Function(UnknownError) then) =
      _$UnknownErrorCopyWithImpl<$Res>;
}

class _$UnknownErrorCopyWithImpl<$Res>
    extends _$ValidateFailureCopyWithImpl<$Res>
    implements $UnknownErrorCopyWith<$Res> {
  _$UnknownErrorCopyWithImpl(
      UnknownError _value, $Res Function(UnknownError) _then)
      : super(_value, (v) => _then(v as UnknownError));

  @override
  UnknownError get _value => super._value as UnknownError;
}

class _$UnknownError implements UnknownError {
  const _$UnknownError();

  @override
  String toString() {
    return 'ValidateFailure.unknownError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnknownError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result emailNotVerified(),
    @required Result vendorNotApproved(),
    @required Result bothNotValid(),
    @required Result unknownError(),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return unknownError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result emailNotVerified(),
    Result vendorNotApproved(),
    Result bothNotValid(),
    Result unknownError(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownError != null) {
      return unknownError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result emailNotVerified(EmailNotVerified value),
    @required Result vendorNotApproved(VendorNotVerified value),
    @required Result bothNotValid(BothNotValid value),
    @required Result unknownError(UnknownError value),
  }) {
    assert(emailNotVerified != null);
    assert(vendorNotApproved != null);
    assert(bothNotValid != null);
    assert(unknownError != null);
    return unknownError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result emailNotVerified(EmailNotVerified value),
    Result vendorNotApproved(VendorNotVerified value),
    Result bothNotValid(BothNotValid value),
    Result unknownError(UnknownError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownError != null) {
      return unknownError(this);
    }
    return orElse();
  }
}

abstract class UnknownError implements ValidateFailure {
  const factory UnknownError() = _$UnknownError;
}
